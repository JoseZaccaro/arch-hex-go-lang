package user

import (
	"api/autentiacion/internal/domain"
	"context"
	"fmt"

	"time"

	"golang.org/x/crypto/bcrypt"
)

func (s Service) Create(ctx context.Context, params domain.UserCreateParams) (id interface{}, err error) {
	now := time.Now().UTC()
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(params.Password), bcrypt.DefaultCost)

	user := &domain.User{
		//* user ID autogenerated,
		Username:     params.Username,
		Email:        params.Email,
		PasswordHash: string(hashedPassword),
		CreatedAt:    now,
		UpdatedAt:    now,
	}

	id, errInsrt := s.UserRepository.Insert(user)

	if errInsrt != nil {
		fmt.Println(errInsrt)
		return nil, errInsrt
	}

	return id, nil
}

func (s Service) Register(ctx context.Context, params domain.UserCreateParams) (*domain.UserMongo, error) {
	now := time.Now().UTC()
	exists, err := s.UserRepository.ExistsByEmail(params.Email)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, fmt.Errorf("user already exists")
	}

	id, errInsrt := s.Create(ctx, params)

	if errInsrt != nil {
		return nil, err
	}

	newUser := &domain.UserMongo{
		ID:           id,
		Username:     params.Username,
		Email:        params.Email,
		PasswordHash: params.Password,
		CreatedAt:    now,
		UpdatedAt:    now,
	}

	return newUser, nil
}

func (s Service) Login(ctx context.Context, email string, password string) (*domain.UserLogin, error) {
	exists, err := s.UserRepository.ExistsByEmail(email)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, fmt.Errorf("email or password incorrect")
	}

	user, err := s.UserRepository.FindUserByEmail(email)
	if err != nil {
		return nil, err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {
		return nil, fmt.Errorf("email or password incorrect")
	}

	userLogin := &domain.UserLogin{
		ID:       user.ID,
		Username: user.Username,
		Email:    user.Email,
	}
	return userLogin, nil
}
